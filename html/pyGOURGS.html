<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>pyGOURGS API documentation</title>
<meta name="description" content="pyGOURGS - Global Optimization by Uniform Random Global Search;
Sohrab Towfighi (C) 2020;
Licence: GPL 3.0;
https://github.com/pySRURGS/pyGOURGS" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyGOURGS</code></h1>
</header>
<section id="section-intro">
<p>pyGOURGS - Global Optimization by Uniform Random Global Search;
Sohrab Towfighi (C) 2020;
Licence: GPL 3.0;
<a href="https://github.com/pySRURGS/pyGOURGS">https://github.com/pySRURGS/pyGOURGS</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
&#39;&#39;&#39;
pyGOURGS - Global Optimization by Uniform Random Global Search;
Sohrab Towfighi (C) 2020;
Licence: GPL 3.0;
https://github.com/pySRURGS/pyGOURGS
&#39;&#39;&#39;

from functools import lru_cache
from methodtools import lru_cache as mt_lru_cache
import weakref
import mpmath
import numpy as np
import random
import pdb
import sys
from sqlitedict import SqliteDict
import tabulate

cache_size=10000

class InvalidOperatorIndex(Exception):
    pass

class InvalidTerminalIndex(Exception):
    pass

class InvalidTreeIndex(Exception):
    pass

def count_nodes_in_tree(tree):
    &#39;&#39;&#39;
        Given an n-ary tree in string format, counts the number of nodes in the 
        tree               
    &#39;&#39;&#39;
    n_terminals = tree.count(&#39;..&#39;)
    n_operators = tree.count(&#39;[&#39;)
    n_nodes = n_terminals + n_operators
    return n_nodes

def get_element_of_cartesian_product(*args, repeat=1, index=0):
    &#34;&#34;&#34;
    Access a specific element of a cartesian product, without needing to iterate
    through the entire product.

    Parameters
    ----------
    args: iterable
        A set of iterables whose cartesian product is being accessed

    repeat: int
        If `args` is only one object, `repeat` specifies the number of times
        to take the cartesian product with itself.

    index: int
        The index of the cartesian product which we want to access

    Returns
    -------
    ith_item: the `index`th element of the cartesian product
    &#34;&#34;&#34;
    pools = [tuple(pool) for pool in args] * repeat
    if len(pools) == 0:
        return []
    len_product = len(pools[0])
    len_pools = len(pools)
    for j in range(1, len_pools):
        len_product = len_product * len(pools[j])
    if index &gt;= len_product:
        raise Exception(&#34;index + 1 is bigger than the length of the product&#34;)
    index_list = []
    for j in range(0, len_pools):
        ith_pool_index = index
        denom = 1
        for k in range(j + 1, len_pools):
            denom = denom * len(pools[k])
        ith_pool_index = ith_pool_index // denom
        if j != 0:
            ith_pool_index = ith_pool_index % len(pools[j])
        index_list.append(ith_pool_index)
    ith_item = []
    for index in range(0, len_pools):
        ith_item.append(pools[index][index_list[index]])
    return ith_item

def get_arity_of_term(start_index, tree):
    &#34;&#34;&#34;
    Returns the arity of the operator which can be placed at index 
    `start_index` within the tree

    Parameters
    ----------
    start_index: int
        Index at which the operator is set to begin. Needs to match to a square
        bracket within the `pyGOURGS` generated string tree

    tree: str
        The solution tree as generated by `pyGOURGS`


    Returns
    -------
    arity: the arity of the operator at `start_index` in `tree`
    &#34;&#34;&#34;
    bracket_counter = 0
    arity = 1
    if tree[start_index] != &#39;[&#39;:
        raise Exception(&#34;Start index must point to a square bracket&#34;)
    len_solution = len(tree)
    for i in range(start_index, len_solution):
        if tree[i] == &#39;[&#39;:
            bracket_counter = bracket_counter + 1
        elif tree[i] == &#39;]&#39;:
            bracket_counter = bracket_counter - 1
        if tree[i] == &#39;,&#39; and bracket_counter == 1:
            arity = arity + 1
        if bracket_counter == 0:
            break
    return arity

def mempower(a, b):
    &#34;&#34;&#34;
    Same as pow, but able to handle extremely large values.

    Parameters
    ----------
    a: int
    b: int

    Returns
    -------
    result: mpmath.ctx_mp_python.mpf (int)
        `a ** b`
    &#34;&#34;&#34;
    result = int(mpmath.power(a, b))
    return result

class PrimitiveSet(object):
    &#34;&#34;&#34;    
    A class used to store the terminals and operators used in this global 
    optimization problem.    
    
    Returns
    -------
    self
        A pyGOURGS.PrimitiveSet object

    Example
    -------
    &gt;&gt;&gt;&gt; import pyGOURGS
    &gt;&gt;&gt;&gt; from operator import add, sub, truediv, mul
    &gt;&gt;&gt;&gt; pset.add_operator(add, 2)
    &gt;&gt;&gt;&gt; pset.add_operator(sub, 2)
    &gt;&gt;&gt;&gt; pset.add_operator(truediv, 2)
    &gt;&gt;&gt;&gt; pset.add_variable(1)
    &gt;&gt;&gt;&gt; pset.add_variable(0)    
    &#34;&#34;&#34;
    def __init__(self):
        self._variables = list()
        self._fitting_parameters = list()
        self._operators = dict()
        self._names = list()

    def add_operator(self, func_handle, arity):
        &#34;&#34;&#34;
        A method that adds a user-specified operator to the list of operators
        stored in self._operators.

        Parameters
        ----------
        func_handle : str
            The name of a function which will be used in the list of operators.

        arity : integer
            The number of inputs of the function `func_handle`       
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        if type(arity) != int:
            raise Exception(&#34;arity must be int&#34;)
        if arity &lt; 1:
            raise Exception(&#34;Invalid arity. Must be &gt;= 1.&#34;)
        try:
            self._operators[arity]
            self._operators[arity].append(func_handle)
        except KeyError:
            self._operators[arity] = [func_handle]

    def add_variable(self, variable):
        &#34;&#34;&#34;
        A method that adds a user-specified variable to the list of terminals
        stored in self._variables.

        Parameters
        ----------
        variable: str
            The variable or value which will be used as a terminal. Its type 
            can be anything, but the operators will need to be able to take 
            `variable` as an input. Within pyGOURGS, it is treated as a string,
            but will eventually be evaluated to whatever results from 
            `eval(variable)`.
            
        Returns
        -------
        None
        &#34;&#34;&#34;
        self._variables.append(variable)
       
    def add_fitting_parameter(self, param_name):
        &#34;&#34;&#34;
        A method that adds a fitting parameter to the list of terminals
        stored in self._fitting_parameters.

        Parameters
        ----------
        param_name : string 
            The name of the fitting parameter which acts as a terminal
            
        Returns
        -------
        None
        &#34;&#34;&#34;
        self._fitting_parameters.append(variable)

    def get_terminals(self):
        &#34;&#34;&#34;
        A method that returns the fitting parameters and variables as one list.

        Parameters
        ----------
        None
            
        Returns
        -------
        terminals : list        
        &#34;&#34;&#34;
        terminals = self._fitting_parameters + self._variables
        return terminals

    def get_arities(self):
        &#34;&#34;&#34;
        A method that returns the arities permissible in this search.

        Parameters
        ----------
        None
            
        Returns
        -------
        arities : a sorted list of integers
        &#34;&#34;&#34;
        return sorted(self._operators.keys())
    
    def get_operators(self):
        &#34;&#34;&#34;
        A method that returns the operators permissible in this search.

        Parameters
        ----------
        None
            
        Returns
        -------
        operators : list of lists, with elements sorted according to increasing 
            arity
        &#34;&#34;&#34;
        operators = []
        keys = self._operators.keys()
        sorted_keys = sorted(keys)
        for i in sorted_keys:
            operators.append(self._operators[i])
        return operators

def decimal_to_base_m(v, m):
    &#34;&#34;&#34;
    A function that converts a decimal number to arbitary base number 

    Parameters
    ----------
    v: int
        The integer in decimal to convert
        
    m: int
        The base of the number system to which we are converting 
        
    Returns
    -------
    result: list of int         
    &#34;&#34;&#34;
    if v &lt; 0:
        raise Exception(&#34;Do not supply negative values&#34;)
    def numberToBase(n, b):
        if n == 0:
            return [0]
        digits = []
        while n:
            digits.append(int(n % b))
            n //= b
        return digits[::-1]
    if v == 0:
        return [0]
    if m == 1:
        result = []
        for i in range(0, v):
            result.append(1)
    elif m &gt;= 2:
        result = numberToBase(v, m)
    else:
        raise Exception(&#34;Invalid m&#34;)
    return result

def base_m_to_decimal(v, m):
    &#34;&#34;&#34;
    A function that converts a base m number to decimal base number 

    Parameters
    ----------
    v: int (or list of int when the output of &#39;decimal_to_base_m&#39; is considered)
        The integer in base m to convert
        
    m: int
        The base of the number system from which we are converting 
        
    Returns
    -------
    result: int        
    &#34;&#34;&#34;
    if m &gt; 10 and type(v) is int:
        msg = &#34;Cannot handle m &gt; 10 and type(v) is int. Input v as list&#34;
        raise Exception(msg)
    if m == 1:
        if type(v) is int:
            v = str(v)
        elif type(v) is list:
            v = [str(i) for i in v]
            v = &#39;&#39;.join(v)
        else:
            raise Exception(&#34;Invalid type of v&#34;)
        result = 0
        for i in v:
            result = result + int(i)            
    elif m &gt;= 2:
        if type(v) is int:
            number = [int(i) for i in str(v)]            
        elif type(v) is list:
            number = v
        else:
            raise Exception(&#34;Invalid type of v&#34;)
        result = 0
        reversed_number = list(reversed(number))
        for i in range(0,len(number)):
            result = result + reversed_number[i] * m**i            
    else:
        raise Exception(&#34;Invalid m&#34;)
    return result    

def deinterleave(num, m):
    &#34;&#34;&#34;
    Given a number `num`, returns the number, deinterleaved, into m folds
    Eg: if `m` were 2, we would be returning the odd and even bits of the number

    Parameters
    ----------
    num : list of ints 
        The number being deinterleaved

    m : int
        An integer denoting the number of folds into which we deinterleave `num`

    Returns
    -------
    m_elements : list of integers
    &#34;&#34;&#34;
    m_elements = []
    for i in range(0,m):
        m_elements.append([])
    while len(num) % m != 0:
        num.insert(0,0)
    for i in range(0, len(num), m):
        for j in range(0, m):
            m_elements[j].append(str(num[i+j]))
    for j in range(0, m):
        m_elements[j] = int(&#34;&#34;.join(m_elements[j]))
    return m_elements

class Enumerator(object):
    
    def __init__(self, pset):
        self._pset = pset
        self.assign_variables_from_pset()
        self._results_for_calculate_Q = {}

    def assign_variables_from_pset(self):
        &#39;&#39;&#39;
        Helper function used when initiating an Enumerator instance.
        &#39;&#39;&#39;
        self._terminals = self._pset.get_terminals()
        self._operators = self._pset._operators
        self._arities = self._pset.get_arities()

    @mt_lru_cache(maxsize=cache_size)
    def ith_n_ary_tree(self, i):
        &#34;&#34;&#34;
        Generates the `i`th n-ary tree.
        
        Maps from `i` to the `i`th n-ary tree using an enumeration of possible 
        trees based on the arity of the operators in `pset`.

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        tree: string
            The n-ary tree as a string where `..` denotes terminal, and [ ] 
            define an operator.
        &#34;&#34;&#34;        
        arities = self._pset.get_arities()
        k = len(arities)
        if i == 0:
            tree = &#39;..&#39;
        elif i in range(1, k+1):
            tree = &#39;[&#39;
            m = arities[i-1]
            for i in range(0, m):
                tree += &#39;..,&#39;
            tree = tree[:-1] + &#39;]&#39;
        else:
            e, j = divmod(i-1, k)            
            m = arities[j]            
            e_base_arity = decimal_to_base_m(e, m)
            list_bits = deinterleave(e_base_arity, m)
            list_bits_deci = [base_m_to_decimal(u, m) \
                                 for u in list_bits]
            subtrees = [self.ith_n_ary_tree(x) for x in list_bits_deci]
            tree = &#39;[&#39; + &#39;,&#39;.join(subtrees) + &#39;]&#39;
        return tree
    
    @mt_lru_cache(maxsize=cache_size)
    def calculate_l_i_b(self, i, b):
        &#34;&#34;&#34;
        Calculates the number of nonterminal nodes with arity `arities[b]` in 
        tree `i`

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        b: int 
            Maps via `arities`[b] to the arity of operators being considered

        Returns
        -------
        l_i_b: int            
        &#34;&#34;&#34;
        arities = self._pset.get_arities()
        k = len(arities)
        if i == 0:
            l_i_b = 0
        elif i in range(1, k+1):
            if b == i-1:
                l_i_b = 1
            else:
                l_i_b = 0
        else:        
            l_i_b = 0
            e, j = divmod(i-1, k) 
            m = arities[j]
            if m == arities[b]:
                l_i_b = l_i_b + 1
            e_base_arity = decimal_to_base_m(e, m)
            list_bits = deinterleave(e_base_arity, m)
            list_bits_deci = [base_m_to_decimal(u, m) \
                                 for u in list_bits]
            for i_deinterleaved in list_bits_deci:
                l_i_b = l_i_b + self.calculate_l_i_b(i_deinterleaved, b)
        return l_i_b

    @mt_lru_cache(maxsize=cache_size)
    def calculate_G_i_b(self, i, b):
        &#34;&#34;&#34;
        Calculates the number of possible configurations of operators of arity 
        arities[`b`] in the `i`th tree.

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        b: int
            Maps via `arities[b]` to the arity of operators being considered

        Returns
        -------
        G_i_b : int
            the number of possible configurations of operators of arity 
            `arities`[b]
        &#34;&#34;&#34;
        arities = self._pset.get_arities()
        f_b = len(self._operators[arities[b]])
        l_i_b = self.calculate_l_i_b(i, b)
        G_i_b = mempower(f_b, l_i_b)
        return G_i_b

    @mt_lru_cache(maxsize=cache_size)
    def calculate_all_G_i_b(self, i):
        &#34;&#34;&#34;
        Calculates the number of possible configurations of operators of arity 
        arities[`b`] in the `i`th tree for all values of `b`

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        list_G_i: list
            A list containing the number of possible configurations of operators 
            of arity `arities`[b] 
        &#34;&#34;&#34;
        arities = self._pset.get_arities()
        k = len(arities)
        list_G_i_b = list()
        for b in range(0, k):
            list_G_i_b.append(self.calculate_G_i_b(i, b))
        return list_G_i_b

    @mt_lru_cache(maxsize=cache_size)
    def calculate_R_i(self, i):
        &#34;&#34;&#34;
        Calculates the number of possible configurations of operators in the 
        `i`th tree.

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        R_i: int
            The number of possible configurations of operators in the `i`th 
            tree
        &#34;&#34;&#34;
        if i == 0:
            return 1
        R_i = 1.0
        all_G_i_b = self.calculate_all_G_i_b(i)
        for G_i_b in all_G_i_b:            
            if G_i_b != 0:
                R_i = R_i * G_i_b
        return R_i

    @mt_lru_cache(maxsize=cache_size)
    def calculate_a_i(self, i):
        &#34;&#34;&#34;
        Calculates the number of terminals in the `i`th tree

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        a_i: int
            The number of terminals in the `i`th tree 
        &#34;&#34;&#34;
        arities = self._pset.get_arities()
        k = len(arities)
        a_i = 0
        if i == 0:
            a_i = 1
        elif i in range(1, k+1):
            a_i = arities[i-1]
        else:
            e, j = divmod(i-1, k) 
            m = arities[j]
            if m == 1:
                a_i = self.calculate_a_i(e)
            else:
                e_base_arity = decimal_to_base_m(e, m)
                list_bits = deinterleave(e_base_arity, m)
                list_bits_deci = [base_m_to_decimal(u, m) \
                                     for u in list_bits]
                for i_deinterleaved in list_bits_deci:
                    a_i = a_i + self.calculate_a_i(i_deinterleaved)                
        return a_i
        
    @mt_lru_cache(maxsize=cache_size)
    def calculate_S_i(self, i):
        &#34;&#34;&#34;
        Calculates the number of possible configurations of terminals in the 
        `i`th tree.

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        S_i: int
            The number of possible configurations of terminals in the `i`th 
            tree
        &#34;&#34;&#34;
        m = len(self._pset.get_terminals())
        j_i = self.calculate_a_i(i)
        S_i = mempower(m, j_i)
        return S_i

    @mt_lru_cache(maxsize=cache_size)
    def calculate_Q(self, N):
        &#34;&#34;&#34;
        Calculates the number of total number of solutions in the solution space

        Parameters
        ----------
        N: int 
            User specified maximum complexity index

        Returns
        -------
        Q: int
            The number of possible solutions in the solution space
        &#34;&#34;&#34; 
        try:
            (Q, weights) = self._results_for_calculate_Q[N]            
        except KeyError:
            pass
        Q = 0
        weights = list()
        for i in range(0, N):
            R_i = self.calculate_R_i(i)
            S_i = self.calculate_S_i(i)
            product = S_i * R_i
            weights.append(product)
            Q = Q + product
        weights = np.array(weights)
        self._results_for_calculate_Q[N] = (Q, weights)
        return Q, weights

    def generate_specified_solution(self, i, r, s, N):        
        &#34;&#34;&#34;
        Generates a candidate solution given all the indices that map to the
        solution space

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        r: int
            A non-negative integer which will be used to map to a configuration 
            of the operators 

        s: int
            A non-negative integer which will be used to map to a configuration 
            of the terminals       

        N: int 
            User specified maximum complexity index
            
        Returns
        -------
        solution: str
            The candidate solution generated from the supplied indices
        &#34;&#34;&#34;
        terminals = self._pset.get_terminals()    
        pset = self._pset
        R_i = self.calculate_R_i(i)
        S_i = self.calculate_S_i(i)
        if r &gt;= R_i or r &lt; 0:
            raise InvalidOperatorIndex()
        if s &gt;= S_i or s &lt; 0:
            raise InvalidTerminalIndex()
        if i &gt; N:
            raise InvalidTreeIndex()
        # generate the tree 
        tree = self.ith_n_ary_tree(i)
        # generate the operator configuration 
        G_i_b_values = self.calculate_all_G_i_b(i)
        G_i_b_values = [int(x) for x in G_i_b_values]
        operator_config_indices = np.unravel_index(r, G_i_b_values)
        operator_config = []
        arities = self._pset.get_arities()
        for b in range(0,len(operator_config_indices)):
            z = operator_config_indices[b]            
            arity = arities[b]
            l_i_b = self.calculate_l_i_b(i, b)
            config = get_element_of_cartesian_product(pset._operators[arity],
                                                          repeat=l_i_b, index=z)
            operator_config.append(config)
        # generate the terminal configuration
        a_i = self.calculate_a_i(i)
        terminal_config = get_element_of_cartesian_product(pset.get_terminals(),
                                                           repeat=a_i, index=s)
        # swap in the operators 
        working_tree = tree
        num_opers = working_tree.count(&#39;[&#39;)
        for i in range(0, num_opers):
            start_index = working_tree.index(&#39;[&#39;)
            arity = get_arity_of_term(start_index, working_tree)            
            index = arities.index(arity)
            operator = operator_config[index].pop()            
            working_tree = (working_tree[0:start_index] + operator + 
                            &#39;(&#39; + working_tree[start_index+1:])
        working_tree = working_tree.replace(&#39;]&#39;,&#39;)&#39;,num_opers)        
        # swap in the terminals 
        num_terminals = working_tree.count(&#39;..&#39;)
        for i in range(0, num_terminals):
            terminal = str(terminal_config.pop())
            working_tree = working_tree.replace(&#39;..&#39;, terminal, 1)        
        tree = working_tree 
        return tree

    def uniform_random_global_search_once(self, N, seed=None):
        &#34;&#34;&#34;
        Generates a random candidate solution

        Parameters
        ----------

        N: int 
            User specified maximum complexity index
            
        Returns
        -------
        candidate_solution: string
            The candidate solution generated from the randomly generated indices
        &#34;&#34;&#34;
        if seed is not None:
            random.seed(seed)
        terminals = self._pset.get_terminals()        
        pset = self._pset    
        _, weights = self.calculate_Q(N)
        i = random.choices(range(0,N), weights=weights)[0]
        R_i = self.calculate_R_i(i)
        S_i = self.calculate_S_i(i)
        r = random.randint(0, R_i-1)
        s = random.randint(0, S_i-1)
        candidate_solution = self.generate_specified_solution(i, r, s, N)
        return candidate_solution
        
    def uniform_random_global_search(self, N, num_soln, seed=None):
        &#34;&#34;&#34;
        Yields (this is a generator) a random candidate solutions `num_soln` 
        times.

        Parameters
        ----------

        N: int 
            User specified maximum complexity index

        num_soln: int
            The number of solutions to generate
        
        seed: int
            This value initializes the random number generator. Runs with the 
            same seed will result in identical outputs, so this seed permits us 
            to run the algorithm deterministically.
            
        Yields
        -------
        candidate_solution: string
            The candidate solution generated
        &#34;&#34;&#34;
        if seed is not None:
            random.seed(seed)
        for j in range(0, num_soln):
            yield self.uniform_random_global_search_once(N)
        
    def exhaustive_global_search(self, N, max_iters=None):
        &#34;&#34;&#34;
        Yields (this is a generator) candidate solutions incrementally 
        increasing the operator/terminals configurations indices and tree index 
        iterator
        
        Parameters
        ----------

        N: int 
            User specified maximum complexity index
        
        max_iters: int
            The maximum number of solutions which can be considered. Will 
            overrule `N` in terms of cutting off the run.
            
        Yields
        -------
        candidate_solution: string
            The candidate solution generated
        &#34;&#34;&#34;        
        iter = 1
        for i in range(0, N):
            R_i = int(self.calculate_R_i(i))
            S_i = int(self.calculate_S_i(i))
            for r in range(0, R_i):
                for s in range(0, S_i):
                    if max_iters is not None:
                        if iter &gt; max_iters:
                            return
                        iter = iter + 1 
                    candidate_solution = self.generate_specified_solution(i,
                                                                    r, s, N)                    
                    yield candidate_solution

                    
def compile(expr, pset):
    &#34;&#34;&#34;
    Compiles the `expr` expression

    Parameters
    ----------

    expr: a string of Python code or any object that when
             converted into string produced a valid Python code
             expression.                 

    pset: Primitive set against which the expression is compiled
        
    Returns
    -------
        a function if the primitive set has 1 or more arguments,
         or return the results produced by evaluating the tree
     
    Note
    ----
    This function needs to be copied into the scope of the script where the 
    problem is defined. 
    &#34;&#34;&#34;    
    code = str(expr)
    if len(pset._variables) &gt; 0:
        args = &#34;,&#34;.join(arg for arg in pset._variables)
        code = &#34;lambda {args}: {code}&#34;.format(args=args, code=code)
    try:
        return eval(code)
    except MemoryError:
        _, _, traceback = sys.exc_info()
        raise MemoryError(&#34;Tree is too long.&#34;, traceback)

def initialize_db(path_to_db):
    &#39;&#39;&#39;
        Initializes the SqliteDict database file with an initial null value
        for the &#39;best_result&#39; key
    &#39;&#39;&#39;
    with SqliteDict(path_to_db, autocommit=True) as results_dict:
        pass        
    return
    
def save_result_to_db(path_to_db, result, input):
    &#39;&#39;&#39;
        Saves results to the SqliteDict file 
    &#39;&#39;&#39;
    with SqliteDict(path_to_db, autocommit=True) as results_dict:
        results_dict[input] = result    

def check_in_db(path_to_db, input):
    &#39;&#39;&#39;
        Checks whether a key already exists in the database
    &#39;&#39;&#39;
    with SqliteDict(path_to_db) as results_dict:
        try:
            results_dict[input]
            return True
        except KeyError:
            return False

class Result(object):
    &#34;&#34;&#34;
    A class to hold a single candidate solution and its performance
    &#34;&#34;&#34;
    def __init__(self, input, score):
        self._input = input
        self._score = score
        self._nodes = None

class ResultList(object):
    &#34;&#34;&#34;
    A class to load all results from a pyGOURGS generated database. 

    Returns
    -------
    self: ResultList
    &#34;&#34;&#34;
    
    def __init__(self, path_to_db):
        self._results = []
        self._path_to_db = path_to_db
        self.load()
        self.sort()        
        self.print()
        
    def load(self):
        &#34;&#34;&#34;
        Loads a database of solutions into the ResultList
        &#34;&#34;&#34;        
        with SqliteDict(self._path_to_db) as results_dict:
            keys = results_dict.keys()        
            for input in keys:
                score = results_dict[input]
                my_result = Result(input, score)
                self._results.append(my_result)    
    
    def sort(self):
        &#34;&#34;&#34;
        Sorts the results in the result list by decreasing value of mean squared 
        error.
        &#34;&#34;&#34;
        self._results = sorted(self._results, key=lambda x: x._score, 
                               reverse=True)

    def count_nodes(self):
        &#34;&#34;&#34;
        For each result, count the number of nodes in the tree
        &#34;&#34;&#34;
        for i in range(0,len(self._results)):
            n_nodes = count_nodes_in_tree(self._results[i]._input)
            self._results[i]._nodes = n_nodes
        
    def print(self, top=2):
        &#34;&#34;&#34;
        Prints the score for the top results in the database. Run `self.sort` 
        prior to executing `self.print`.
        
        Parameters
        ----------
                
        top: int 
            The number of results to display. Will be the best models if 
            `self.sort` has been run prior to printing.
                        
        Returns
        -------
        table_string: string
        &#34;&#34;&#34;
        table = []
        header = [&#34;Score&#34;]
        for i in range(0, top):
            row = [self._results[i]._input, self._results[i]._score]
            table.append(row)
        table_string = tabulate.tabulate(table, headers=header)
        print(table_string)


if __name__ == &#39;__main__&#39;:
    ps = PrimitiveSet()
    ps.add_operator(&#39;add&#39;, 2)
    ps.add_operator(&#39;sub&#39;, 2)
    ps.add_operator(&#39;div&#39;, 2)
    ps.add_operator(&#39;cos&#39;, 1)
    ps.add_operator(&#39;progn3&#39;, 3)
    ps.add_variable(&#39;x&#39;)
    ps.add_variable(&#39;y&#39;)
    en = Enumerator(ps)
    print(en.uniform_random_global_search_once(1000))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyGOURGS.base_m_to_decimal"><code class="name flex">
<span>def <span class="ident">base_m_to_decimal</span></span>(<span>v, m)</span>
</code></dt>
<dd>
<section class="desc"><p>A function that converts a base m number to decimal base number </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code>int</code> (or <code>list</code> of <code>int</code> <code>when</code> <code>the</code> <code>output</code> of <code>'decimal_to_base_m'</code> <code>is</code> <code>considered</code>)</dt>
<dd>The integer in base m to convert</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>The base of the number system from which we are converting</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_m_to_decimal(v, m):
    &#34;&#34;&#34;
    A function that converts a base m number to decimal base number 

    Parameters
    ----------
    v: int (or list of int when the output of &#39;decimal_to_base_m&#39; is considered)
        The integer in base m to convert
        
    m: int
        The base of the number system from which we are converting 
        
    Returns
    -------
    result: int        
    &#34;&#34;&#34;
    if m &gt; 10 and type(v) is int:
        msg = &#34;Cannot handle m &gt; 10 and type(v) is int. Input v as list&#34;
        raise Exception(msg)
    if m == 1:
        if type(v) is int:
            v = str(v)
        elif type(v) is list:
            v = [str(i) for i in v]
            v = &#39;&#39;.join(v)
        else:
            raise Exception(&#34;Invalid type of v&#34;)
        result = 0
        for i in v:
            result = result + int(i)            
    elif m &gt;= 2:
        if type(v) is int:
            number = [int(i) for i in str(v)]            
        elif type(v) is list:
            number = v
        else:
            raise Exception(&#34;Invalid type of v&#34;)
        result = 0
        reversed_number = list(reversed(number))
        for i in range(0,len(number)):
            result = result + reversed_number[i] * m**i            
    else:
        raise Exception(&#34;Invalid m&#34;)
    return result    </code></pre>
</details>
</dd>
<dt id="pyGOURGS.check_in_db"><code class="name flex">
<span>def <span class="ident">check_in_db</span></span>(<span>path_to_db, input)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether a key already exists in the database</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_in_db(path_to_db, input):
    &#39;&#39;&#39;
        Checks whether a key already exists in the database
    &#39;&#39;&#39;
    with SqliteDict(path_to_db) as results_dict:
        try:
            results_dict[input]
            return True
        except KeyError:
            return False</code></pre>
</details>
</dd>
<dt id="pyGOURGS.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>expr, pset)</span>
</code></dt>
<dd>
<section class="desc"><p>Compiles the <code>expr</code> expression</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expr</code></strong> :&ensp;<code>a</code> <code>string</code> of <code>Python</code> <code>code</code> or <code>any</code> <code>object</code> <code>that</code> <code>when</code></dt>
<dd>converted into string produced a valid Python code
expression.</dd>
<dt><strong><code>pset</code></strong> :&ensp;<code>Primitive</code> <code>set</code> <code>against</code> <code>which</code> <code>the</code> <code>expression</code> <code>is</code> <code>compiled</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>a function if the primitive set has 1 or more arguments,
 or return the results produced by evaluating the tree
</code></pre>
<h2 id="note">Note</h2>
<p>This function needs to be copied into the scope of the script where the
problem is defined.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(expr, pset):
    &#34;&#34;&#34;
    Compiles the `expr` expression

    Parameters
    ----------

    expr: a string of Python code or any object that when
             converted into string produced a valid Python code
             expression.                 

    pset: Primitive set against which the expression is compiled
        
    Returns
    -------
        a function if the primitive set has 1 or more arguments,
         or return the results produced by evaluating the tree
     
    Note
    ----
    This function needs to be copied into the scope of the script where the 
    problem is defined. 
    &#34;&#34;&#34;    
    code = str(expr)
    if len(pset._variables) &gt; 0:
        args = &#34;,&#34;.join(arg for arg in pset._variables)
        code = &#34;lambda {args}: {code}&#34;.format(args=args, code=code)
    try:
        return eval(code)
    except MemoryError:
        _, _, traceback = sys.exc_info()
        raise MemoryError(&#34;Tree is too long.&#34;, traceback)</code></pre>
</details>
</dd>
<dt id="pyGOURGS.count_nodes_in_tree"><code class="name flex">
<span>def <span class="ident">count_nodes_in_tree</span></span>(<span>tree)</span>
</code></dt>
<dd>
<section class="desc"><p>Given an n-ary tree in string format, counts the number of nodes in the
tree</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_nodes_in_tree(tree):
    &#39;&#39;&#39;
        Given an n-ary tree in string format, counts the number of nodes in the 
        tree               
    &#39;&#39;&#39;
    n_terminals = tree.count(&#39;..&#39;)
    n_operators = tree.count(&#39;[&#39;)
    n_nodes = n_terminals + n_operators
    return n_nodes</code></pre>
</details>
</dd>
<dt id="pyGOURGS.decimal_to_base_m"><code class="name flex">
<span>def <span class="ident">decimal_to_base_m</span></span>(<span>v, m)</span>
</code></dt>
<dd>
<section class="desc"><p>A function that converts a decimal number to arbitary base number </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code>int</code></dt>
<dd>The integer in decimal to convert</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>The base of the number system to which we are converting</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decimal_to_base_m(v, m):
    &#34;&#34;&#34;
    A function that converts a decimal number to arbitary base number 

    Parameters
    ----------
    v: int
        The integer in decimal to convert
        
    m: int
        The base of the number system to which we are converting 
        
    Returns
    -------
    result: list of int         
    &#34;&#34;&#34;
    if v &lt; 0:
        raise Exception(&#34;Do not supply negative values&#34;)
    def numberToBase(n, b):
        if n == 0:
            return [0]
        digits = []
        while n:
            digits.append(int(n % b))
            n //= b
        return digits[::-1]
    if v == 0:
        return [0]
    if m == 1:
        result = []
        for i in range(0, v):
            result.append(1)
    elif m &gt;= 2:
        result = numberToBase(v, m)
    else:
        raise Exception(&#34;Invalid m&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="pyGOURGS.deinterleave"><code class="name flex">
<span>def <span class="ident">deinterleave</span></span>(<span>num, m)</span>
</code></dt>
<dd>
<section class="desc"><p>Given a number <code>num</code>, returns the number, deinterleaved, into m folds
Eg: if <code>m</code> were 2, we would be returning the odd and even bits of the number</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num</code></strong> :&ensp;<code>list</code> of <code>ints</code></dt>
<dd>The number being deinterleaved</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>An integer denoting the number of folds into which we deinterleave <code>num</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>m_elements</code></strong> :&ensp;<code>list</code> of <code>integers</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deinterleave(num, m):
    &#34;&#34;&#34;
    Given a number `num`, returns the number, deinterleaved, into m folds
    Eg: if `m` were 2, we would be returning the odd and even bits of the number

    Parameters
    ----------
    num : list of ints 
        The number being deinterleaved

    m : int
        An integer denoting the number of folds into which we deinterleave `num`

    Returns
    -------
    m_elements : list of integers
    &#34;&#34;&#34;
    m_elements = []
    for i in range(0,m):
        m_elements.append([])
    while len(num) % m != 0:
        num.insert(0,0)
    for i in range(0, len(num), m):
        for j in range(0, m):
            m_elements[j].append(str(num[i+j]))
    for j in range(0, m):
        m_elements[j] = int(&#34;&#34;.join(m_elements[j]))
    return m_elements</code></pre>
</details>
</dd>
<dt id="pyGOURGS.get_arity_of_term"><code class="name flex">
<span>def <span class="ident">get_arity_of_term</span></span>(<span>start_index, tree)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the arity of the operator which can be placed at index
<code>start_index</code> within the tree</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index at which the operator is set to begin. Needs to match to a square
bracket within the <a title="pyGOURGS" href="#pyGOURGS"><code>pyGOURGS</code></a> generated string tree</dd>
<dt><strong><code>tree</code></strong> :&ensp;<code>str</code></dt>
<dd>The solution tree as generated by <a title="pyGOURGS" href="#pyGOURGS"><code>pyGOURGS</code></a></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>arity</code></strong> :&ensp;<code>the</code> <code>arity</code> of <code>the</code> <code>operator</code> <code>at</code> <code>start_index</code> <code>in</code> <code>tree</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_arity_of_term(start_index, tree):
    &#34;&#34;&#34;
    Returns the arity of the operator which can be placed at index 
    `start_index` within the tree

    Parameters
    ----------
    start_index: int
        Index at which the operator is set to begin. Needs to match to a square
        bracket within the `pyGOURGS` generated string tree

    tree: str
        The solution tree as generated by `pyGOURGS`


    Returns
    -------
    arity: the arity of the operator at `start_index` in `tree`
    &#34;&#34;&#34;
    bracket_counter = 0
    arity = 1
    if tree[start_index] != &#39;[&#39;:
        raise Exception(&#34;Start index must point to a square bracket&#34;)
    len_solution = len(tree)
    for i in range(start_index, len_solution):
        if tree[i] == &#39;[&#39;:
            bracket_counter = bracket_counter + 1
        elif tree[i] == &#39;]&#39;:
            bracket_counter = bracket_counter - 1
        if tree[i] == &#39;,&#39; and bracket_counter == 1:
            arity = arity + 1
        if bracket_counter == 0:
            break
    return arity</code></pre>
</details>
</dd>
<dt id="pyGOURGS.get_element_of_cartesian_product"><code class="name flex">
<span>def <span class="ident">get_element_of_cartesian_product</span></span>(<span>*args, repeat=1, index=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Access a specific element of a cartesian product, without needing to iterate
through the entire product.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>iterable</code></dt>
<dd>A set of iterables whose cartesian product is being accessed</dd>
<dt><strong><code>repeat</code></strong> :&ensp;<code>int</code></dt>
<dd>If <code>args</code> is only one object, <code>repeat</code> specifies the number of times
to take the cartesian product with itself.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the cartesian product which we want to access</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ith_item</code></strong> :&ensp;<code>the</code> <code>`index```th</code> <code>element</code> of <code>the</code> <code>cartesian</code> <code>product</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_element_of_cartesian_product(*args, repeat=1, index=0):
    &#34;&#34;&#34;
    Access a specific element of a cartesian product, without needing to iterate
    through the entire product.

    Parameters
    ----------
    args: iterable
        A set of iterables whose cartesian product is being accessed

    repeat: int
        If `args` is only one object, `repeat` specifies the number of times
        to take the cartesian product with itself.

    index: int
        The index of the cartesian product which we want to access

    Returns
    -------
    ith_item: the `index`th element of the cartesian product
    &#34;&#34;&#34;
    pools = [tuple(pool) for pool in args] * repeat
    if len(pools) == 0:
        return []
    len_product = len(pools[0])
    len_pools = len(pools)
    for j in range(1, len_pools):
        len_product = len_product * len(pools[j])
    if index &gt;= len_product:
        raise Exception(&#34;index + 1 is bigger than the length of the product&#34;)
    index_list = []
    for j in range(0, len_pools):
        ith_pool_index = index
        denom = 1
        for k in range(j + 1, len_pools):
            denom = denom * len(pools[k])
        ith_pool_index = ith_pool_index // denom
        if j != 0:
            ith_pool_index = ith_pool_index % len(pools[j])
        index_list.append(ith_pool_index)
    ith_item = []
    for index in range(0, len_pools):
        ith_item.append(pools[index][index_list[index]])
    return ith_item</code></pre>
</details>
</dd>
<dt id="pyGOURGS.initialize_db"><code class="name flex">
<span>def <span class="ident">initialize_db</span></span>(<span>path_to_db)</span>
</code></dt>
<dd>
<section class="desc"><p>Initializes the SqliteDict database file with an initial null value
for the 'best_result' key</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_db(path_to_db):
    &#39;&#39;&#39;
        Initializes the SqliteDict database file with an initial null value
        for the &#39;best_result&#39; key
    &#39;&#39;&#39;
    with SqliteDict(path_to_db, autocommit=True) as results_dict:
        pass        
    return</code></pre>
</details>
</dd>
<dt id="pyGOURGS.mempower"><code class="name flex">
<span>def <span class="ident">mempower</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<section class="desc"><p>Same as pow, but able to handle extremely large values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>mpmath.ctx_mp_python.mpf</code> (<code>int</code>)</dt>
<dd><code>a ** b</code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mempower(a, b):
    &#34;&#34;&#34;
    Same as pow, but able to handle extremely large values.

    Parameters
    ----------
    a: int
    b: int

    Returns
    -------
    result: mpmath.ctx_mp_python.mpf (int)
        `a ** b`
    &#34;&#34;&#34;
    result = int(mpmath.power(a, b))
    return result</code></pre>
</details>
</dd>
<dt id="pyGOURGS.save_result_to_db"><code class="name flex">
<span>def <span class="ident">save_result_to_db</span></span>(<span>path_to_db, result, input)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves results to the SqliteDict file</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_result_to_db(path_to_db, result, input):
    &#39;&#39;&#39;
        Saves results to the SqliteDict file 
    &#39;&#39;&#39;
    with SqliteDict(path_to_db, autocommit=True) as results_dict:
        results_dict[input] = result    </code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyGOURGS.Enumerator"><code class="flex name class">
<span>class <span class="ident">Enumerator</span></span>
<span>(</span><span>pset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Enumerator(object):
    
    def __init__(self, pset):
        self._pset = pset
        self.assign_variables_from_pset()
        self._results_for_calculate_Q = {}

    def assign_variables_from_pset(self):
        &#39;&#39;&#39;
        Helper function used when initiating an Enumerator instance.
        &#39;&#39;&#39;
        self._terminals = self._pset.get_terminals()
        self._operators = self._pset._operators
        self._arities = self._pset.get_arities()

    @mt_lru_cache(maxsize=cache_size)
    def ith_n_ary_tree(self, i):
        &#34;&#34;&#34;
        Generates the `i`th n-ary tree.
        
        Maps from `i` to the `i`th n-ary tree using an enumeration of possible 
        trees based on the arity of the operators in `pset`.

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        tree: string
            The n-ary tree as a string where `..` denotes terminal, and [ ] 
            define an operator.
        &#34;&#34;&#34;        
        arities = self._pset.get_arities()
        k = len(arities)
        if i == 0:
            tree = &#39;..&#39;
        elif i in range(1, k+1):
            tree = &#39;[&#39;
            m = arities[i-1]
            for i in range(0, m):
                tree += &#39;..,&#39;
            tree = tree[:-1] + &#39;]&#39;
        else:
            e, j = divmod(i-1, k)            
            m = arities[j]            
            e_base_arity = decimal_to_base_m(e, m)
            list_bits = deinterleave(e_base_arity, m)
            list_bits_deci = [base_m_to_decimal(u, m) \
                                 for u in list_bits]
            subtrees = [self.ith_n_ary_tree(x) for x in list_bits_deci]
            tree = &#39;[&#39; + &#39;,&#39;.join(subtrees) + &#39;]&#39;
        return tree
    
    @mt_lru_cache(maxsize=cache_size)
    def calculate_l_i_b(self, i, b):
        &#34;&#34;&#34;
        Calculates the number of nonterminal nodes with arity `arities[b]` in 
        tree `i`

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        b: int 
            Maps via `arities`[b] to the arity of operators being considered

        Returns
        -------
        l_i_b: int            
        &#34;&#34;&#34;
        arities = self._pset.get_arities()
        k = len(arities)
        if i == 0:
            l_i_b = 0
        elif i in range(1, k+1):
            if b == i-1:
                l_i_b = 1
            else:
                l_i_b = 0
        else:        
            l_i_b = 0
            e, j = divmod(i-1, k) 
            m = arities[j]
            if m == arities[b]:
                l_i_b = l_i_b + 1
            e_base_arity = decimal_to_base_m(e, m)
            list_bits = deinterleave(e_base_arity, m)
            list_bits_deci = [base_m_to_decimal(u, m) \
                                 for u in list_bits]
            for i_deinterleaved in list_bits_deci:
                l_i_b = l_i_b + self.calculate_l_i_b(i_deinterleaved, b)
        return l_i_b

    @mt_lru_cache(maxsize=cache_size)
    def calculate_G_i_b(self, i, b):
        &#34;&#34;&#34;
        Calculates the number of possible configurations of operators of arity 
        arities[`b`] in the `i`th tree.

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        b: int
            Maps via `arities[b]` to the arity of operators being considered

        Returns
        -------
        G_i_b : int
            the number of possible configurations of operators of arity 
            `arities`[b]
        &#34;&#34;&#34;
        arities = self._pset.get_arities()
        f_b = len(self._operators[arities[b]])
        l_i_b = self.calculate_l_i_b(i, b)
        G_i_b = mempower(f_b, l_i_b)
        return G_i_b

    @mt_lru_cache(maxsize=cache_size)
    def calculate_all_G_i_b(self, i):
        &#34;&#34;&#34;
        Calculates the number of possible configurations of operators of arity 
        arities[`b`] in the `i`th tree for all values of `b`

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        list_G_i: list
            A list containing the number of possible configurations of operators 
            of arity `arities`[b] 
        &#34;&#34;&#34;
        arities = self._pset.get_arities()
        k = len(arities)
        list_G_i_b = list()
        for b in range(0, k):
            list_G_i_b.append(self.calculate_G_i_b(i, b))
        return list_G_i_b

    @mt_lru_cache(maxsize=cache_size)
    def calculate_R_i(self, i):
        &#34;&#34;&#34;
        Calculates the number of possible configurations of operators in the 
        `i`th tree.

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        R_i: int
            The number of possible configurations of operators in the `i`th 
            tree
        &#34;&#34;&#34;
        if i == 0:
            return 1
        R_i = 1.0
        all_G_i_b = self.calculate_all_G_i_b(i)
        for G_i_b in all_G_i_b:            
            if G_i_b != 0:
                R_i = R_i * G_i_b
        return R_i

    @mt_lru_cache(maxsize=cache_size)
    def calculate_a_i(self, i):
        &#34;&#34;&#34;
        Calculates the number of terminals in the `i`th tree

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        a_i: int
            The number of terminals in the `i`th tree 
        &#34;&#34;&#34;
        arities = self._pset.get_arities()
        k = len(arities)
        a_i = 0
        if i == 0:
            a_i = 1
        elif i in range(1, k+1):
            a_i = arities[i-1]
        else:
            e, j = divmod(i-1, k) 
            m = arities[j]
            if m == 1:
                a_i = self.calculate_a_i(e)
            else:
                e_base_arity = decimal_to_base_m(e, m)
                list_bits = deinterleave(e_base_arity, m)
                list_bits_deci = [base_m_to_decimal(u, m) \
                                     for u in list_bits]
                for i_deinterleaved in list_bits_deci:
                    a_i = a_i + self.calculate_a_i(i_deinterleaved)                
        return a_i
        
    @mt_lru_cache(maxsize=cache_size)
    def calculate_S_i(self, i):
        &#34;&#34;&#34;
        Calculates the number of possible configurations of terminals in the 
        `i`th tree.

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        Returns
        -------
        S_i: int
            The number of possible configurations of terminals in the `i`th 
            tree
        &#34;&#34;&#34;
        m = len(self._pset.get_terminals())
        j_i = self.calculate_a_i(i)
        S_i = mempower(m, j_i)
        return S_i

    @mt_lru_cache(maxsize=cache_size)
    def calculate_Q(self, N):
        &#34;&#34;&#34;
        Calculates the number of total number of solutions in the solution space

        Parameters
        ----------
        N: int 
            User specified maximum complexity index

        Returns
        -------
        Q: int
            The number of possible solutions in the solution space
        &#34;&#34;&#34; 
        try:
            (Q, weights) = self._results_for_calculate_Q[N]            
        except KeyError:
            pass
        Q = 0
        weights = list()
        for i in range(0, N):
            R_i = self.calculate_R_i(i)
            S_i = self.calculate_S_i(i)
            product = S_i * R_i
            weights.append(product)
            Q = Q + product
        weights = np.array(weights)
        self._results_for_calculate_Q[N] = (Q, weights)
        return Q, weights

    def generate_specified_solution(self, i, r, s, N):        
        &#34;&#34;&#34;
        Generates a candidate solution given all the indices that map to the
        solution space

        Parameters
        ----------
        i: int
            A non-negative integer which will be used to map to a unique n-ary 
            trees

        r: int
            A non-negative integer which will be used to map to a configuration 
            of the operators 

        s: int
            A non-negative integer which will be used to map to a configuration 
            of the terminals       

        N: int 
            User specified maximum complexity index
            
        Returns
        -------
        solution: str
            The candidate solution generated from the supplied indices
        &#34;&#34;&#34;
        terminals = self._pset.get_terminals()    
        pset = self._pset
        R_i = self.calculate_R_i(i)
        S_i = self.calculate_S_i(i)
        if r &gt;= R_i or r &lt; 0:
            raise InvalidOperatorIndex()
        if s &gt;= S_i or s &lt; 0:
            raise InvalidTerminalIndex()
        if i &gt; N:
            raise InvalidTreeIndex()
        # generate the tree 
        tree = self.ith_n_ary_tree(i)
        # generate the operator configuration 
        G_i_b_values = self.calculate_all_G_i_b(i)
        G_i_b_values = [int(x) for x in G_i_b_values]
        operator_config_indices = np.unravel_index(r, G_i_b_values)
        operator_config = []
        arities = self._pset.get_arities()
        for b in range(0,len(operator_config_indices)):
            z = operator_config_indices[b]            
            arity = arities[b]
            l_i_b = self.calculate_l_i_b(i, b)
            config = get_element_of_cartesian_product(pset._operators[arity],
                                                          repeat=l_i_b, index=z)
            operator_config.append(config)
        # generate the terminal configuration
        a_i = self.calculate_a_i(i)
        terminal_config = get_element_of_cartesian_product(pset.get_terminals(),
                                                           repeat=a_i, index=s)
        # swap in the operators 
        working_tree = tree
        num_opers = working_tree.count(&#39;[&#39;)
        for i in range(0, num_opers):
            start_index = working_tree.index(&#39;[&#39;)
            arity = get_arity_of_term(start_index, working_tree)            
            index = arities.index(arity)
            operator = operator_config[index].pop()            
            working_tree = (working_tree[0:start_index] + operator + 
                            &#39;(&#39; + working_tree[start_index+1:])
        working_tree = working_tree.replace(&#39;]&#39;,&#39;)&#39;,num_opers)        
        # swap in the terminals 
        num_terminals = working_tree.count(&#39;..&#39;)
        for i in range(0, num_terminals):
            terminal = str(terminal_config.pop())
            working_tree = working_tree.replace(&#39;..&#39;, terminal, 1)        
        tree = working_tree 
        return tree

    def uniform_random_global_search_once(self, N, seed=None):
        &#34;&#34;&#34;
        Generates a random candidate solution

        Parameters
        ----------

        N: int 
            User specified maximum complexity index
            
        Returns
        -------
        candidate_solution: string
            The candidate solution generated from the randomly generated indices
        &#34;&#34;&#34;
        if seed is not None:
            random.seed(seed)
        terminals = self._pset.get_terminals()        
        pset = self._pset    
        _, weights = self.calculate_Q(N)
        i = random.choices(range(0,N), weights=weights)[0]
        R_i = self.calculate_R_i(i)
        S_i = self.calculate_S_i(i)
        r = random.randint(0, R_i-1)
        s = random.randint(0, S_i-1)
        candidate_solution = self.generate_specified_solution(i, r, s, N)
        return candidate_solution
        
    def uniform_random_global_search(self, N, num_soln, seed=None):
        &#34;&#34;&#34;
        Yields (this is a generator) a random candidate solutions `num_soln` 
        times.

        Parameters
        ----------

        N: int 
            User specified maximum complexity index

        num_soln: int
            The number of solutions to generate
        
        seed: int
            This value initializes the random number generator. Runs with the 
            same seed will result in identical outputs, so this seed permits us 
            to run the algorithm deterministically.
            
        Yields
        -------
        candidate_solution: string
            The candidate solution generated
        &#34;&#34;&#34;
        if seed is not None:
            random.seed(seed)
        for j in range(0, num_soln):
            yield self.uniform_random_global_search_once(N)
        
    def exhaustive_global_search(self, N, max_iters=None):
        &#34;&#34;&#34;
        Yields (this is a generator) candidate solutions incrementally 
        increasing the operator/terminals configurations indices and tree index 
        iterator
        
        Parameters
        ----------

        N: int 
            User specified maximum complexity index
        
        max_iters: int
            The maximum number of solutions which can be considered. Will 
            overrule `N` in terms of cutting off the run.
            
        Yields
        -------
        candidate_solution: string
            The candidate solution generated
        &#34;&#34;&#34;        
        iter = 1
        for i in range(0, N):
            R_i = int(self.calculate_R_i(i))
            S_i = int(self.calculate_S_i(i))
            for r in range(0, R_i):
                for s in range(0, S_i):
                    if max_iters is not None:
                        if iter &gt; max_iters:
                            return
                        iter = iter + 1 
                    candidate_solution = self.generate_specified_solution(i,
                                                                    r, s, N)                    
                    yield candidate_solution</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyGOURGS.Enumerator.assign_variables_from_pset"><code class="name flex">
<span>def <span class="ident">assign_variables_from_pset</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper function used when initiating an Enumerator instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_variables_from_pset(self):
    &#39;&#39;&#39;
    Helper function used when initiating an Enumerator instance.
    &#39;&#39;&#39;
    self._terminals = self._pset.get_terminals()
    self._operators = self._pset._operators
    self._arities = self._pset.get_arities()</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.calculate_G_i_b"><code class="name flex">
<span>def <span class="ident">calculate_G_i_b</span></span>(<span>self, i, b)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the number of possible configurations of operators of arity
arities[<code>b</code>] in the <code>i</code>th tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a unique n-ary
trees</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>Maps via <code>arities[b]</code> to the arity of operators being considered</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>G_i_b</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of possible configurations of operators of arity
<code>arities</code>[b]</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mt_lru_cache(maxsize=cache_size)
def calculate_G_i_b(self, i, b):
    &#34;&#34;&#34;
    Calculates the number of possible configurations of operators of arity 
    arities[`b`] in the `i`th tree.

    Parameters
    ----------
    i: int
        A non-negative integer which will be used to map to a unique n-ary 
        trees

    b: int
        Maps via `arities[b]` to the arity of operators being considered

    Returns
    -------
    G_i_b : int
        the number of possible configurations of operators of arity 
        `arities`[b]
    &#34;&#34;&#34;
    arities = self._pset.get_arities()
    f_b = len(self._operators[arities[b]])
    l_i_b = self.calculate_l_i_b(i, b)
    G_i_b = mempower(f_b, l_i_b)
    return G_i_b</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.calculate_Q"><code class="name flex">
<span>def <span class="ident">calculate_Q</span></span>(<span>self, N)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the number of total number of solutions in the solution space</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>User specified maximum complexity index</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Q</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of possible solutions in the solution space</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mt_lru_cache(maxsize=cache_size)
def calculate_Q(self, N):
    &#34;&#34;&#34;
    Calculates the number of total number of solutions in the solution space

    Parameters
    ----------
    N: int 
        User specified maximum complexity index

    Returns
    -------
    Q: int
        The number of possible solutions in the solution space
    &#34;&#34;&#34; 
    try:
        (Q, weights) = self._results_for_calculate_Q[N]            
    except KeyError:
        pass
    Q = 0
    weights = list()
    for i in range(0, N):
        R_i = self.calculate_R_i(i)
        S_i = self.calculate_S_i(i)
        product = S_i * R_i
        weights.append(product)
        Q = Q + product
    weights = np.array(weights)
    self._results_for_calculate_Q[N] = (Q, weights)
    return Q, weights</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.calculate_R_i"><code class="name flex">
<span>def <span class="ident">calculate_R_i</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the number of possible configurations of operators in the
<code>i</code>th tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a unique n-ary
trees</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R_i</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of possible configurations of operators in the <code>i</code>th
tree</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mt_lru_cache(maxsize=cache_size)
def calculate_R_i(self, i):
    &#34;&#34;&#34;
    Calculates the number of possible configurations of operators in the 
    `i`th tree.

    Parameters
    ----------
    i: int
        A non-negative integer which will be used to map to a unique n-ary 
        trees

    Returns
    -------
    R_i: int
        The number of possible configurations of operators in the `i`th 
        tree
    &#34;&#34;&#34;
    if i == 0:
        return 1
    R_i = 1.0
    all_G_i_b = self.calculate_all_G_i_b(i)
    for G_i_b in all_G_i_b:            
        if G_i_b != 0:
            R_i = R_i * G_i_b
    return R_i</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.calculate_S_i"><code class="name flex">
<span>def <span class="ident">calculate_S_i</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the number of possible configurations of terminals in the
<code>i</code>th tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a unique n-ary
trees</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S_i</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of possible configurations of terminals in the <code>i</code>th
tree</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mt_lru_cache(maxsize=cache_size)
def calculate_S_i(self, i):
    &#34;&#34;&#34;
    Calculates the number of possible configurations of terminals in the 
    `i`th tree.

    Parameters
    ----------
    i: int
        A non-negative integer which will be used to map to a unique n-ary 
        trees

    Returns
    -------
    S_i: int
        The number of possible configurations of terminals in the `i`th 
        tree
    &#34;&#34;&#34;
    m = len(self._pset.get_terminals())
    j_i = self.calculate_a_i(i)
    S_i = mempower(m, j_i)
    return S_i</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.calculate_a_i"><code class="name flex">
<span>def <span class="ident">calculate_a_i</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the number of terminals in the <code>i</code>th tree</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a unique n-ary
trees</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a_i</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of terminals in the <code>i</code>th tree</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mt_lru_cache(maxsize=cache_size)
def calculate_a_i(self, i):
    &#34;&#34;&#34;
    Calculates the number of terminals in the `i`th tree

    Parameters
    ----------
    i: int
        A non-negative integer which will be used to map to a unique n-ary 
        trees

    Returns
    -------
    a_i: int
        The number of terminals in the `i`th tree 
    &#34;&#34;&#34;
    arities = self._pset.get_arities()
    k = len(arities)
    a_i = 0
    if i == 0:
        a_i = 1
    elif i in range(1, k+1):
        a_i = arities[i-1]
    else:
        e, j = divmod(i-1, k) 
        m = arities[j]
        if m == 1:
            a_i = self.calculate_a_i(e)
        else:
            e_base_arity = decimal_to_base_m(e, m)
            list_bits = deinterleave(e_base_arity, m)
            list_bits_deci = [base_m_to_decimal(u, m) \
                                 for u in list_bits]
            for i_deinterleaved in list_bits_deci:
                a_i = a_i + self.calculate_a_i(i_deinterleaved)                
    return a_i</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.calculate_all_G_i_b"><code class="name flex">
<span>def <span class="ident">calculate_all_G_i_b</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the number of possible configurations of operators of arity
arities[<code>b</code>] in the <code>i</code>th tree for all values of <code>b</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a unique n-ary
trees</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list_G_i</code></strong> :&ensp;<code>list</code></dt>
<dd>A list containing the number of possible configurations of operators
of arity <code>arities</code>[b]</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mt_lru_cache(maxsize=cache_size)
def calculate_all_G_i_b(self, i):
    &#34;&#34;&#34;
    Calculates the number of possible configurations of operators of arity 
    arities[`b`] in the `i`th tree for all values of `b`

    Parameters
    ----------
    i: int
        A non-negative integer which will be used to map to a unique n-ary 
        trees

    Returns
    -------
    list_G_i: list
        A list containing the number of possible configurations of operators 
        of arity `arities`[b] 
    &#34;&#34;&#34;
    arities = self._pset.get_arities()
    k = len(arities)
    list_G_i_b = list()
    for b in range(0, k):
        list_G_i_b.append(self.calculate_G_i_b(i, b))
    return list_G_i_b</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.calculate_l_i_b"><code class="name flex">
<span>def <span class="ident">calculate_l_i_b</span></span>(<span>self, i, b)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the number of nonterminal nodes with arity <code>arities[b]</code> in
tree <code>i</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a unique n-ary
trees</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>Maps via <code>arities</code>[b] to the arity of operators being considered</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>l_i_b</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mt_lru_cache(maxsize=cache_size)
def calculate_l_i_b(self, i, b):
    &#34;&#34;&#34;
    Calculates the number of nonterminal nodes with arity `arities[b]` in 
    tree `i`

    Parameters
    ----------
    i: int
        A non-negative integer which will be used to map to a unique n-ary 
        trees

    b: int 
        Maps via `arities`[b] to the arity of operators being considered

    Returns
    -------
    l_i_b: int            
    &#34;&#34;&#34;
    arities = self._pset.get_arities()
    k = len(arities)
    if i == 0:
        l_i_b = 0
    elif i in range(1, k+1):
        if b == i-1:
            l_i_b = 1
        else:
            l_i_b = 0
    else:        
        l_i_b = 0
        e, j = divmod(i-1, k) 
        m = arities[j]
        if m == arities[b]:
            l_i_b = l_i_b + 1
        e_base_arity = decimal_to_base_m(e, m)
        list_bits = deinterleave(e_base_arity, m)
        list_bits_deci = [base_m_to_decimal(u, m) \
                             for u in list_bits]
        for i_deinterleaved in list_bits_deci:
            l_i_b = l_i_b + self.calculate_l_i_b(i_deinterleaved, b)
    return l_i_b</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.exhaustive_global_search"><code class="name flex">
<span>def <span class="ident">exhaustive_global_search</span></span>(<span>self, N, max_iters=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Yields (this is a generator) candidate solutions incrementally
increasing the operator/terminals configurations indices and tree index
iterator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>User specified maximum complexity index</dd>
<dt><strong><code>max_iters</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of solutions which can be considered. Will
overrule <code>N</code> in terms of cutting off the run.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>candidate_solution</code></strong> :&ensp;<code>string</code></dt>
<dd>The candidate solution generated</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exhaustive_global_search(self, N, max_iters=None):
    &#34;&#34;&#34;
    Yields (this is a generator) candidate solutions incrementally 
    increasing the operator/terminals configurations indices and tree index 
    iterator
    
    Parameters
    ----------

    N: int 
        User specified maximum complexity index
    
    max_iters: int
        The maximum number of solutions which can be considered. Will 
        overrule `N` in terms of cutting off the run.
        
    Yields
    -------
    candidate_solution: string
        The candidate solution generated
    &#34;&#34;&#34;        
    iter = 1
    for i in range(0, N):
        R_i = int(self.calculate_R_i(i))
        S_i = int(self.calculate_S_i(i))
        for r in range(0, R_i):
            for s in range(0, S_i):
                if max_iters is not None:
                    if iter &gt; max_iters:
                        return
                    iter = iter + 1 
                candidate_solution = self.generate_specified_solution(i,
                                                                r, s, N)                    
                yield candidate_solution</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.generate_specified_solution"><code class="name flex">
<span>def <span class="ident">generate_specified_solution</span></span>(<span>self, i, r, s, N)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a candidate solution given all the indices that map to the
solution space</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a unique n-ary
trees</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a configuration
of the operators</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a configuration
of the terminals</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>User specified maximum complexity index</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>solution</code></strong> :&ensp;<code>str</code></dt>
<dd>The candidate solution generated from the supplied indices</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_specified_solution(self, i, r, s, N):        
    &#34;&#34;&#34;
    Generates a candidate solution given all the indices that map to the
    solution space

    Parameters
    ----------
    i: int
        A non-negative integer which will be used to map to a unique n-ary 
        trees

    r: int
        A non-negative integer which will be used to map to a configuration 
        of the operators 

    s: int
        A non-negative integer which will be used to map to a configuration 
        of the terminals       

    N: int 
        User specified maximum complexity index
        
    Returns
    -------
    solution: str
        The candidate solution generated from the supplied indices
    &#34;&#34;&#34;
    terminals = self._pset.get_terminals()    
    pset = self._pset
    R_i = self.calculate_R_i(i)
    S_i = self.calculate_S_i(i)
    if r &gt;= R_i or r &lt; 0:
        raise InvalidOperatorIndex()
    if s &gt;= S_i or s &lt; 0:
        raise InvalidTerminalIndex()
    if i &gt; N:
        raise InvalidTreeIndex()
    # generate the tree 
    tree = self.ith_n_ary_tree(i)
    # generate the operator configuration 
    G_i_b_values = self.calculate_all_G_i_b(i)
    G_i_b_values = [int(x) for x in G_i_b_values]
    operator_config_indices = np.unravel_index(r, G_i_b_values)
    operator_config = []
    arities = self._pset.get_arities()
    for b in range(0,len(operator_config_indices)):
        z = operator_config_indices[b]            
        arity = arities[b]
        l_i_b = self.calculate_l_i_b(i, b)
        config = get_element_of_cartesian_product(pset._operators[arity],
                                                      repeat=l_i_b, index=z)
        operator_config.append(config)
    # generate the terminal configuration
    a_i = self.calculate_a_i(i)
    terminal_config = get_element_of_cartesian_product(pset.get_terminals(),
                                                       repeat=a_i, index=s)
    # swap in the operators 
    working_tree = tree
    num_opers = working_tree.count(&#39;[&#39;)
    for i in range(0, num_opers):
        start_index = working_tree.index(&#39;[&#39;)
        arity = get_arity_of_term(start_index, working_tree)            
        index = arities.index(arity)
        operator = operator_config[index].pop()            
        working_tree = (working_tree[0:start_index] + operator + 
                        &#39;(&#39; + working_tree[start_index+1:])
    working_tree = working_tree.replace(&#39;]&#39;,&#39;)&#39;,num_opers)        
    # swap in the terminals 
    num_terminals = working_tree.count(&#39;..&#39;)
    for i in range(0, num_terminals):
        terminal = str(terminal_config.pop())
        working_tree = working_tree.replace(&#39;..&#39;, terminal, 1)        
    tree = working_tree 
    return tree</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.ith_n_ary_tree"><code class="name flex">
<span>def <span class="ident">ith_n_ary_tree</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates the <code>i</code>th n-ary tree.</p>
<p>Maps from <code>i</code> to the <code>i</code>th n-ary tree using an enumeration of possible
trees based on the arity of the operators in <code>pset</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>A non-negative integer which will be used to map to a unique n-ary
trees</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tree</code></strong> :&ensp;<code>string</code></dt>
<dd>The n-ary tree as a string where <code>..</code> denotes terminal, and [ ]
define an operator.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@mt_lru_cache(maxsize=cache_size)
def ith_n_ary_tree(self, i):
    &#34;&#34;&#34;
    Generates the `i`th n-ary tree.
    
    Maps from `i` to the `i`th n-ary tree using an enumeration of possible 
    trees based on the arity of the operators in `pset`.

    Parameters
    ----------
    i: int
        A non-negative integer which will be used to map to a unique n-ary 
        trees

    Returns
    -------
    tree: string
        The n-ary tree as a string where `..` denotes terminal, and [ ] 
        define an operator.
    &#34;&#34;&#34;        
    arities = self._pset.get_arities()
    k = len(arities)
    if i == 0:
        tree = &#39;..&#39;
    elif i in range(1, k+1):
        tree = &#39;[&#39;
        m = arities[i-1]
        for i in range(0, m):
            tree += &#39;..,&#39;
        tree = tree[:-1] + &#39;]&#39;
    else:
        e, j = divmod(i-1, k)            
        m = arities[j]            
        e_base_arity = decimal_to_base_m(e, m)
        list_bits = deinterleave(e_base_arity, m)
        list_bits_deci = [base_m_to_decimal(u, m) \
                             for u in list_bits]
        subtrees = [self.ith_n_ary_tree(x) for x in list_bits_deci]
        tree = &#39;[&#39; + &#39;,&#39;.join(subtrees) + &#39;]&#39;
    return tree</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.uniform_random_global_search"><code class="name flex">
<span>def <span class="ident">uniform_random_global_search</span></span>(<span>self, N, num_soln, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Yields (this is a generator) a random candidate solutions <code>num_soln</code>
times.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>User specified maximum complexity index</dd>
<dt><strong><code>num_soln</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of solutions to generate</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>This value initializes the random number generator. Runs with the
same seed will result in identical outputs, so this seed permits us
to run the algorithm deterministically.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>candidate_solution</code></strong> :&ensp;<code>string</code></dt>
<dd>The candidate solution generated</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniform_random_global_search(self, N, num_soln, seed=None):
    &#34;&#34;&#34;
    Yields (this is a generator) a random candidate solutions `num_soln` 
    times.

    Parameters
    ----------

    N: int 
        User specified maximum complexity index

    num_soln: int
        The number of solutions to generate
    
    seed: int
        This value initializes the random number generator. Runs with the 
        same seed will result in identical outputs, so this seed permits us 
        to run the algorithm deterministically.
        
    Yields
    -------
    candidate_solution: string
        The candidate solution generated
    &#34;&#34;&#34;
    if seed is not None:
        random.seed(seed)
    for j in range(0, num_soln):
        yield self.uniform_random_global_search_once(N)</code></pre>
</details>
</dd>
<dt id="pyGOURGS.Enumerator.uniform_random_global_search_once"><code class="name flex">
<span>def <span class="ident">uniform_random_global_search_once</span></span>(<span>self, N, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a random candidate solution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>User specified maximum complexity index</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>candidate_solution</code></strong> :&ensp;<code>string</code></dt>
<dd>The candidate solution generated from the randomly generated indices</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniform_random_global_search_once(self, N, seed=None):
    &#34;&#34;&#34;
    Generates a random candidate solution

    Parameters
    ----------

    N: int 
        User specified maximum complexity index
        
    Returns
    -------
    candidate_solution: string
        The candidate solution generated from the randomly generated indices
    &#34;&#34;&#34;
    if seed is not None:
        random.seed(seed)
    terminals = self._pset.get_terminals()        
    pset = self._pset    
    _, weights = self.calculate_Q(N)
    i = random.choices(range(0,N), weights=weights)[0]
    R_i = self.calculate_R_i(i)
    S_i = self.calculate_S_i(i)
    r = random.randint(0, R_i-1)
    s = random.randint(0, S_i-1)
    candidate_solution = self.generate_specified_solution(i, r, s, N)
    return candidate_solution</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyGOURGS.InvalidOperatorIndex"><code class="flex name class">
<span>class <span class="ident">InvalidOperatorIndex</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidOperatorIndex(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pyGOURGS.InvalidTerminalIndex"><code class="flex name class">
<span>class <span class="ident">InvalidTerminalIndex</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidTerminalIndex(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pyGOURGS.InvalidTreeIndex"><code class="flex name class">
<span>class <span class="ident">InvalidTreeIndex</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidTreeIndex(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pyGOURGS.PrimitiveSet"><code class="flex name class">
<span>class <span class="ident">PrimitiveSet</span></span>
</code></dt>
<dd>
<section class="desc"><p>A class used to store the terminals and operators used in this global
optimization problem.
</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>A pyGOURGS.PrimitiveSet object</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>&gt;&gt;&gt;&gt; import pyGOURGS
&gt;&gt;&gt;&gt; from operator import add, sub, truediv, mul
&gt;&gt;&gt;&gt; pset.add_operator(add, 2)
&gt;&gt;&gt;&gt; pset.add_operator(sub, 2)
&gt;&gt;&gt;&gt; pset.add_operator(truediv, 2)
&gt;&gt;&gt;&gt; pset.add_variable(1)
&gt;&gt;&gt;&gt; pset.add_variable(0)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrimitiveSet(object):
    &#34;&#34;&#34;    
    A class used to store the terminals and operators used in this global 
    optimization problem.    
    
    Returns
    -------
    self
        A pyGOURGS.PrimitiveSet object

    Example
    -------
    &gt;&gt;&gt;&gt; import pyGOURGS
    &gt;&gt;&gt;&gt; from operator import add, sub, truediv, mul
    &gt;&gt;&gt;&gt; pset.add_operator(add, 2)
    &gt;&gt;&gt;&gt; pset.add_operator(sub, 2)
    &gt;&gt;&gt;&gt; pset.add_operator(truediv, 2)
    &gt;&gt;&gt;&gt; pset.add_variable(1)
    &gt;&gt;&gt;&gt; pset.add_variable(0)    
    &#34;&#34;&#34;
    def __init__(self):
        self._variables = list()
        self._fitting_parameters = list()
        self._operators = dict()
        self._names = list()

    def add_operator(self, func_handle, arity):
        &#34;&#34;&#34;
        A method that adds a user-specified operator to the list of operators
        stored in self._operators.

        Parameters
        ----------
        func_handle : str
            The name of a function which will be used in the list of operators.

        arity : integer
            The number of inputs of the function `func_handle`       
        
        Returns
        -------
        None
        &#34;&#34;&#34;
        if type(arity) != int:
            raise Exception(&#34;arity must be int&#34;)
        if arity &lt; 1:
            raise Exception(&#34;Invalid arity. Must be &gt;= 1.&#34;)
        try:
            self._operators[arity]
            self._operators[arity].append(func_handle)
        except KeyError:
            self._operators[arity] = [func_handle]

    def add_variable(self, variable):
        &#34;&#34;&#34;
        A method that adds a user-specified variable to the list of terminals
        stored in self._variables.

        Parameters
        ----------
        variable: str
            The variable or value which will be used as a terminal. Its type 
            can be anything, but the operators will need to be able to take 
            `variable` as an input. Within pyGOURGS, it is treated as a string,
            but will eventually be evaluated to whatever results from 
            `eval(variable)`.
            
        Returns
        -------
        None
        &#34;&#34;&#34;
        self._variables.append(variable)
       
    def add_fitting_parameter(self, param_name):
        &#34;&#34;&#34;
        A method that adds a fitting parameter to the list of terminals
        stored in self._fitting_parameters.

        Parameters
        ----------
        param_name : string 
            The name of the fitting parameter which acts as a terminal
            
        Returns
        -------
        None
        &#34;&#34;&#34;
        self._fitting_parameters.append(variable)

    def get_terminals(self):
        &#34;&#34;&#34;
        A method that returns the fitting parameters and variables as one list.

        Parameters
        ----------
        None
            
        Returns
        -------
        terminals : list        
        &#34;&#34;&#34;
        terminals = self._fitting_parameters + self._variables
        return terminals

    def get_arities(self):
        &#34;&#34;&#34;
        A method that returns the arities permissible in this search.

        Parameters
        ----------
        None
            
        Returns
        -------
        arities : a sorted list of integers
        &#34;&#34;&#34;
        return sorted(self._operators.keys())
    
    def get_operators(self):
        &#34;&#34;&#34;
        A method that returns the operators permissible in this search.

        Parameters
        ----------
        None
            
        Returns
        -------
        operators : list of lists, with elements sorted according to increasing 
            arity
        &#34;&#34;&#34;
        operators = []
        keys = self._operators.keys()
        sorted_keys = sorted(keys)
        for i in sorted_keys:
            operators.append(self._operators[i])
        return operators</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyGOURGS.PrimitiveSet.add_fitting_parameter"><code class="name flex">
<span>def <span class="ident">add_fitting_parameter</span></span>(<span>self, param_name)</span>
</code></dt>
<dd>
<section class="desc"><p>A method that adds a fitting parameter to the list of terminals
stored in self._fitting_parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>param_name</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the fitting parameter which acts as a terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fitting_parameter(self, param_name):
    &#34;&#34;&#34;
    A method that adds a fitting parameter to the list of terminals
    stored in self._fitting_parameters.

    Parameters
    ----------
    param_name : string 
        The name of the fitting parameter which acts as a terminal
        
    Returns
    -------
    None
    &#34;&#34;&#34;
    self._fitting_parameters.append(variable)</code></pre>
</details>
</dd>
<dt id="pyGOURGS.PrimitiveSet.add_operator"><code class="name flex">
<span>def <span class="ident">add_operator</span></span>(<span>self, func_handle, arity)</span>
</code></dt>
<dd>
<section class="desc"><p>A method that adds a user-specified operator to the list of operators
stored in self._operators.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func_handle</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of a function which will be used in the list of operators.</dd>
<dt><strong><code>arity</code></strong> :&ensp;<code>integer</code></dt>
<dd>The number of inputs of the function <code>func_handle</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_operator(self, func_handle, arity):
    &#34;&#34;&#34;
    A method that adds a user-specified operator to the list of operators
    stored in self._operators.

    Parameters
    ----------
    func_handle : str
        The name of a function which will be used in the list of operators.

    arity : integer
        The number of inputs of the function `func_handle`       
    
    Returns
    -------
    None
    &#34;&#34;&#34;
    if type(arity) != int:
        raise Exception(&#34;arity must be int&#34;)
    if arity &lt; 1:
        raise Exception(&#34;Invalid arity. Must be &gt;= 1.&#34;)
    try:
        self._operators[arity]
        self._operators[arity].append(func_handle)
    except KeyError:
        self._operators[arity] = [func_handle]</code></pre>
</details>
</dd>
<dt id="pyGOURGS.PrimitiveSet.add_variable"><code class="name flex">
<span>def <span class="ident">add_variable</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<section class="desc"><p>A method that adds a user-specified variable to the list of terminals
stored in self._variables.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>variable</code></strong> :&ensp;<code>str</code></dt>
<dd>The variable or value which will be used as a terminal. Its type
can be anything, but the operators will need to be able to take
<code>variable</code> as an input. Within pyGOURGS, it is treated as a string,
but will eventually be evaluated to whatever results from
<code>eval(variable)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_variable(self, variable):
    &#34;&#34;&#34;
    A method that adds a user-specified variable to the list of terminals
    stored in self._variables.

    Parameters
    ----------
    variable: str
        The variable or value which will be used as a terminal. Its type 
        can be anything, but the operators will need to be able to take 
        `variable` as an input. Within pyGOURGS, it is treated as a string,
        but will eventually be evaluated to whatever results from 
        `eval(variable)`.
        
    Returns
    -------
    None
    &#34;&#34;&#34;
    self._variables.append(variable)</code></pre>
</details>
</dd>
<dt id="pyGOURGS.PrimitiveSet.get_arities"><code class="name flex">
<span>def <span class="ident">get_arities</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>A method that returns the arities permissible in this search.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>arities</code></strong> :&ensp;<code>a</code> <code>sorted</code> <code>list</code> of <code>integers</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_arities(self):
    &#34;&#34;&#34;
    A method that returns the arities permissible in this search.

    Parameters
    ----------
    None
        
    Returns
    -------
    arities : a sorted list of integers
    &#34;&#34;&#34;
    return sorted(self._operators.keys())</code></pre>
</details>
</dd>
<dt id="pyGOURGS.PrimitiveSet.get_operators"><code class="name flex">
<span>def <span class="ident">get_operators</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>A method that returns the operators permissible in this search.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>operators</code></strong> :&ensp;<code>list</code> of <code>lists</code>, <code>with</code> <code>elements</code> <code>sorted</code> <code>according</code> <code>to</code> <code>increasing</code></dt>
<dd>arity</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_operators(self):
    &#34;&#34;&#34;
    A method that returns the operators permissible in this search.

    Parameters
    ----------
    None
        
    Returns
    -------
    operators : list of lists, with elements sorted according to increasing 
        arity
    &#34;&#34;&#34;
    operators = []
    keys = self._operators.keys()
    sorted_keys = sorted(keys)
    for i in sorted_keys:
        operators.append(self._operators[i])
    return operators</code></pre>
</details>
</dd>
<dt id="pyGOURGS.PrimitiveSet.get_terminals"><code class="name flex">
<span>def <span class="ident">get_terminals</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>A method that returns the fitting parameters and variables as one list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>terminals</code></strong> :&ensp;<code>list</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_terminals(self):
    &#34;&#34;&#34;
    A method that returns the fitting parameters and variables as one list.

    Parameters
    ----------
    None
        
    Returns
    -------
    terminals : list        
    &#34;&#34;&#34;
    terminals = self._fitting_parameters + self._variables
    return terminals</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyGOURGS.Result"><code class="flex name class">
<span>class <span class="ident">Result</span></span>
<span>(</span><span>input, score)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to hold a single candidate solution and its performance</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Result(object):
    &#34;&#34;&#34;
    A class to hold a single candidate solution and its performance
    &#34;&#34;&#34;
    def __init__(self, input, score):
        self._input = input
        self._score = score
        self._nodes = None</code></pre>
</details>
</dd>
<dt id="pyGOURGS.ResultList"><code class="flex name class">
<span>class <span class="ident">ResultList</span></span>
<span>(</span><span>path_to_db)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to load all results from a pyGOURGS generated database. </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<a title="pyGOURGS.ResultList" href="#pyGOURGS.ResultList"><code>ResultList</code></a></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResultList(object):
    &#34;&#34;&#34;
    A class to load all results from a pyGOURGS generated database. 

    Returns
    -------
    self: ResultList
    &#34;&#34;&#34;
    
    def __init__(self, path_to_db):
        self._results = []
        self._path_to_db = path_to_db
        self.load()
        self.sort()        
        self.print()
        
    def load(self):
        &#34;&#34;&#34;
        Loads a database of solutions into the ResultList
        &#34;&#34;&#34;        
        with SqliteDict(self._path_to_db) as results_dict:
            keys = results_dict.keys()        
            for input in keys:
                score = results_dict[input]
                my_result = Result(input, score)
                self._results.append(my_result)    
    
    def sort(self):
        &#34;&#34;&#34;
        Sorts the results in the result list by decreasing value of mean squared 
        error.
        &#34;&#34;&#34;
        self._results = sorted(self._results, key=lambda x: x._score, 
                               reverse=True)

    def count_nodes(self):
        &#34;&#34;&#34;
        For each result, count the number of nodes in the tree
        &#34;&#34;&#34;
        for i in range(0,len(self._results)):
            n_nodes = count_nodes_in_tree(self._results[i]._input)
            self._results[i]._nodes = n_nodes
        
    def print(self, top=2):
        &#34;&#34;&#34;
        Prints the score for the top results in the database. Run `self.sort` 
        prior to executing `self.print`.
        
        Parameters
        ----------
                
        top: int 
            The number of results to display. Will be the best models if 
            `self.sort` has been run prior to printing.
                        
        Returns
        -------
        table_string: string
        &#34;&#34;&#34;
        table = []
        header = [&#34;Score&#34;]
        for i in range(0, top):
            row = [self._results[i]._input, self._results[i]._score]
            table.append(row)
        table_string = tabulate.tabulate(table, headers=header)
        print(table_string)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyGOURGS.ResultList.count_nodes"><code class="name flex">
<span>def <span class="ident">count_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>For each result, count the number of nodes in the tree</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_nodes(self):
    &#34;&#34;&#34;
    For each result, count the number of nodes in the tree
    &#34;&#34;&#34;
    for i in range(0,len(self._results)):
        n_nodes = count_nodes_in_tree(self._results[i]._input)
        self._results[i]._nodes = n_nodes</code></pre>
</details>
</dd>
<dt id="pyGOURGS.ResultList.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads a database of solutions into the ResultList</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self):
    &#34;&#34;&#34;
    Loads a database of solutions into the ResultList
    &#34;&#34;&#34;        
    with SqliteDict(self._path_to_db) as results_dict:
        keys = results_dict.keys()        
        for input in keys:
            score = results_dict[input]
            my_result = Result(input, score)
            self._results.append(my_result)    </code></pre>
</details>
</dd>
<dt id="pyGOURGS.ResultList.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, top=2)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints the score for the top results in the database. Run <code>self.sort</code>
prior to executing <code>self.print</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>top</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of results to display. Will be the best models if
<code>self.sort</code> has been run prior to printing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>table_string</code></strong> :&ensp;<code>string</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, top=2):
    &#34;&#34;&#34;
    Prints the score for the top results in the database. Run `self.sort` 
    prior to executing `self.print`.
    
    Parameters
    ----------
            
    top: int 
        The number of results to display. Will be the best models if 
        `self.sort` has been run prior to printing.
                    
    Returns
    -------
    table_string: string
    &#34;&#34;&#34;
    table = []
    header = [&#34;Score&#34;]
    for i in range(0, top):
        row = [self._results[i]._input, self._results[i]._score]
        table.append(row)
    table_string = tabulate.tabulate(table, headers=header)
    print(table_string)</code></pre>
</details>
</dd>
<dt id="pyGOURGS.ResultList.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Sorts the results in the result list by decreasing value of mean squared
error.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self):
    &#34;&#34;&#34;
    Sorts the results in the result list by decreasing value of mean squared 
    error.
    &#34;&#34;&#34;
    self._results = sorted(self._results, key=lambda x: x._score, 
                           reverse=True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pyGOURGS Home" href="https://pyGOURGS.github.io">
<img src="https://github.com/pySRURGS/pyGOURGS/blob/master/image/pyGOURGS.svg" alt=""> pyGOURGS
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyGOURGS.base_m_to_decimal" href="#pyGOURGS.base_m_to_decimal">base_m_to_decimal</a></code></li>
<li><code><a title="pyGOURGS.check_in_db" href="#pyGOURGS.check_in_db">check_in_db</a></code></li>
<li><code><a title="pyGOURGS.compile" href="#pyGOURGS.compile">compile</a></code></li>
<li><code><a title="pyGOURGS.count_nodes_in_tree" href="#pyGOURGS.count_nodes_in_tree">count_nodes_in_tree</a></code></li>
<li><code><a title="pyGOURGS.decimal_to_base_m" href="#pyGOURGS.decimal_to_base_m">decimal_to_base_m</a></code></li>
<li><code><a title="pyGOURGS.deinterleave" href="#pyGOURGS.deinterleave">deinterleave</a></code></li>
<li><code><a title="pyGOURGS.get_arity_of_term" href="#pyGOURGS.get_arity_of_term">get_arity_of_term</a></code></li>
<li><code><a title="pyGOURGS.get_element_of_cartesian_product" href="#pyGOURGS.get_element_of_cartesian_product">get_element_of_cartesian_product</a></code></li>
<li><code><a title="pyGOURGS.initialize_db" href="#pyGOURGS.initialize_db">initialize_db</a></code></li>
<li><code><a title="pyGOURGS.mempower" href="#pyGOURGS.mempower">mempower</a></code></li>
<li><code><a title="pyGOURGS.save_result_to_db" href="#pyGOURGS.save_result_to_db">save_result_to_db</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyGOURGS.Enumerator" href="#pyGOURGS.Enumerator">Enumerator</a></code></h4>
<ul class="">
<li><code><a title="pyGOURGS.Enumerator.assign_variables_from_pset" href="#pyGOURGS.Enumerator.assign_variables_from_pset">assign_variables_from_pset</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.calculate_G_i_b" href="#pyGOURGS.Enumerator.calculate_G_i_b">calculate_G_i_b</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.calculate_Q" href="#pyGOURGS.Enumerator.calculate_Q">calculate_Q</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.calculate_R_i" href="#pyGOURGS.Enumerator.calculate_R_i">calculate_R_i</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.calculate_S_i" href="#pyGOURGS.Enumerator.calculate_S_i">calculate_S_i</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.calculate_a_i" href="#pyGOURGS.Enumerator.calculate_a_i">calculate_a_i</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.calculate_all_G_i_b" href="#pyGOURGS.Enumerator.calculate_all_G_i_b">calculate_all_G_i_b</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.calculate_l_i_b" href="#pyGOURGS.Enumerator.calculate_l_i_b">calculate_l_i_b</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.exhaustive_global_search" href="#pyGOURGS.Enumerator.exhaustive_global_search">exhaustive_global_search</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.generate_specified_solution" href="#pyGOURGS.Enumerator.generate_specified_solution">generate_specified_solution</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.ith_n_ary_tree" href="#pyGOURGS.Enumerator.ith_n_ary_tree">ith_n_ary_tree</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.uniform_random_global_search" href="#pyGOURGS.Enumerator.uniform_random_global_search">uniform_random_global_search</a></code></li>
<li><code><a title="pyGOURGS.Enumerator.uniform_random_global_search_once" href="#pyGOURGS.Enumerator.uniform_random_global_search_once">uniform_random_global_search_once</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyGOURGS.InvalidOperatorIndex" href="#pyGOURGS.InvalidOperatorIndex">InvalidOperatorIndex</a></code></h4>
</li>
<li>
<h4><code><a title="pyGOURGS.InvalidTerminalIndex" href="#pyGOURGS.InvalidTerminalIndex">InvalidTerminalIndex</a></code></h4>
</li>
<li>
<h4><code><a title="pyGOURGS.InvalidTreeIndex" href="#pyGOURGS.InvalidTreeIndex">InvalidTreeIndex</a></code></h4>
</li>
<li>
<h4><code><a title="pyGOURGS.PrimitiveSet" href="#pyGOURGS.PrimitiveSet">PrimitiveSet</a></code></h4>
<ul class="">
<li><code><a title="pyGOURGS.PrimitiveSet.add_fitting_parameter" href="#pyGOURGS.PrimitiveSet.add_fitting_parameter">add_fitting_parameter</a></code></li>
<li><code><a title="pyGOURGS.PrimitiveSet.add_operator" href="#pyGOURGS.PrimitiveSet.add_operator">add_operator</a></code></li>
<li><code><a title="pyGOURGS.PrimitiveSet.add_variable" href="#pyGOURGS.PrimitiveSet.add_variable">add_variable</a></code></li>
<li><code><a title="pyGOURGS.PrimitiveSet.get_arities" href="#pyGOURGS.PrimitiveSet.get_arities">get_arities</a></code></li>
<li><code><a title="pyGOURGS.PrimitiveSet.get_operators" href="#pyGOURGS.PrimitiveSet.get_operators">get_operators</a></code></li>
<li><code><a title="pyGOURGS.PrimitiveSet.get_terminals" href="#pyGOURGS.PrimitiveSet.get_terminals">get_terminals</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyGOURGS.Result" href="#pyGOURGS.Result">Result</a></code></h4>
</li>
<li>
<h4><code><a title="pyGOURGS.ResultList" href="#pyGOURGS.ResultList">ResultList</a></code></h4>
<ul class="">
<li><code><a title="pyGOURGS.ResultList.count_nodes" href="#pyGOURGS.ResultList.count_nodes">count_nodes</a></code></li>
<li><code><a title="pyGOURGS.ResultList.load" href="#pyGOURGS.ResultList.load">load</a></code></li>
<li><code><a title="pyGOURGS.ResultList.print" href="#pyGOURGS.ResultList.print">print</a></code></li>
<li><code><a title="pyGOURGS.ResultList.sort" href="#pyGOURGS.ResultList.sort">sort</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>